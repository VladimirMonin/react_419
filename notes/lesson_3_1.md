# Практикум 3.1: Создаем с нуля универсальный компонент-кнопку с Props и TypeScript

## 1. Подготовка окружения: Интеграция Bootstrap в React-проект

Этот этап является подготовительным, но критически важным. Мы подключаем внешнюю библиотеку стилей, чтобы не писать весь CSS с нуля, а сосредоточиться на логике и архитектуре React-компонентов. [cite: 147, 548]

### Цель этапа: заложить фундамент для стилизации

* Избежать написания собственных CSS-стилей для базовых элементов, таких как кнопки, цвета и отступы.
* Получить доступ к большой библиотеке готовых иконок (Bootstrap Icons) для нашего будущего компонента. [cite: 148, 149]
* Убедиться, что стили корректно применяются ко всему приложению.
* Проверить, что среда разработки правильно настроена для работы с внешними CSS-зависимостями.
* Этот шаг позволяет нам сразу получить визуально приятный результат и сфокусироваться на TypeScript и React.

### Шаг 1: Установка зависимостей через npm

* Для работы нам понадобятся три пакета, которые мы установим одной командой в терминале. [cite: 158]
* `bootstrap`: основная CSS-библиотека со стилями для компонентов.
* `bootstrap-icons`: отдельный пакет, содержащий CSS для шрифта с иконками.
* `react-bootstrap`: вспомогательная библиотека, которая предоставляет готовые React-компоненты для Bootstrap (мы ее устанавливаем на будущее).
* **КОМАНДА ДЛЯ ТЕРМИНАЛА:**

```bash
npm install bootstrap bootstrap-icons react-bootstrap
```

### Шаг 2: Глобальный импорт стилей в `main.tsx`

* Чтобы стили Bootstrap были доступны во всем приложении, их нужно импортировать в самую корневую точку нашего проекта. [cite: 151]
* Этой точкой входа обычно является файл `src/main.tsx`. [cite: 161]
* Мы добавляем два импорта — один для основных стилей, другой для иконок.
* **ПРИМЕР №3.1.1** (ФАЙЛ: `src/main.tsx`)

```tsx
import 'bootstrap/dist/css/bootstrap.min.css';
import 'bootstrap-icons/font/bootstrap-icons.css';
```

* Эти импорты не присваиваются переменным; они просто сообщают сборщику проекта (Vite), что эти CSS-файлы нужно включить в финальную сборку.

### Шаг 3: Проверка работоспособности

* После импорта стилей самый надежный способ проверить, что все сработало, — это увидеть изменения на странице. [cite: 164]
* Шрифт по умолчанию во всем приложении должен измениться на шрифт Bootstrap. [cite: 165]
* Можно временно добавить в компонент `App.tsx` обычный тег `<button>` с классами Bootstrap, чтобы убедиться в их применении: `<button className="btn btn-dark">Тест</button>`. [cite: 169]
* Аналогично можно проверить и иконки, добавив тег `<i>`: `<i className="bi bi-shop"></i>`. [cite: 171, 173]
* Если вы видите стилизованную кнопку и иконку магазина, значит, окружение готово к дальнейшей работе.

******

## 2. Проектирование "контракта" кнопки (API): TypeScript Interface и Types

Прежде чем писать код, мы должны спроектировать его "публичный API". В React-компонентах таким API является объект `props`. TypeScript позволяет нам создать строгий "контракт", описывающий, какие данные компонент ожидает на вход. [cite: 11]

### Концепция: Props как публичный контракт

* Использование `interface` в TypeScript — это наиболее полный и каноничный способ описания `props`. [cite: 14, 19]
* Этот интерфейс гарантирует, что мы не сможем передать в компонент лишние свойства или свойства неверного типа.
* Он также обеспечивает автодополнение в IDE, что значительно ускоряет разработку.
* Для больших проектов такие интерфейсы и типы часто выносят в отдельный файл (например, `types.ts`), чтобы их можно было переиспользовать в разных частях приложения. [cite: 24, 26, 53]
* Мы определяем, какими "ручками настройки" будет обладать наш компонент. [cite: 124]

### Создание базового интерфейса `ButtonProps`

* Начнем с простого: наша кнопка должна принимать цвет фона и заголовок.
* **ПРИМЕР №3.1.2** (ФАЙЛ: `src/components/StandartButton.tsx`)

```tsx
export interface ButtonProps {
    BGcolor: BSColors
    title: string
}
```

* `BGcolor` будет отвечать за цвет фона кнопки (например, "dark", "warning").
* `title` — это текстовая метка, которая будет отображаться на кнопке или во всплывающей подсказке.

******

### Типизация с ограничениями: Создание кастомного типа `BSColors`

* Типизировать `BGcolor` просто как `string` — плохая практика, так как это позволит передать любое строковое значение, а нам нужны только конкретные цвета из Bootstrap. [cite: 213, 551]
* Для этого мы создаем собственный тип-объединение (union type), который перечисляет все допустимые строковые значения. [cite: 217]
* **ПРИМЕР №3.1.2** (ФАЙЛ: `src/components/StandartButton.tsx`)

```tsx
export type BSColors = "dark" | "warning" | "danger" | "info" | "primary" | "success"
```

* Теперь, если мы попытаемся передать в `BGcolor` что-то, кроме этих шести строк, TypeScript выдаст ошибку еще на этапе написания кода. [cite: 226, 315]

### Расширение контракта для новых возможностей

* Хороший компонент должен быть гибким. Расширим его API, чтобы он мог отображать не только текст, но и иконку. [cite: 206]
* Для этого добавим еще два свойства в наш интерфейс.
* `icon`: строка с названием иконки из библиотеки Bootstrap Icons (например, "basket-fill").
* `btnType`: свойство, которое будет определять режим работы кнопки — "textButton" или "iconButton".
* **ПРИМЕР №3.1.3** (ФАЙЛ: `src/components/StandartButton.tsx`)

```tsx
export interface ButtonProps {
    BGcolor: BSColors
    icon: string
    title: string
    btnType: "textButton" | "iconButton" // Union type прямо в интерфейсе
}
```

******

## 3. Реализация компонента: Динамические классы и условный рендеринг

Теперь, когда у нас есть четкий "контракт" (`interface`), мы можем приступить к написанию JSX-разметки и логики самого компонента `<StandardButton>`.

### Основа компонента и динамическая стилизация

* Компонент представляет собой функцию, которая принимает `props` и возвращает JSX. [cite: 251]
* Для динамического формирования `className` мы используем шаблонные строки JavaScript.
* Это позволяет нам "подставлять" значение из `props.BGcolor` прямо в строку с классами. [cite: 254, 255]
* Таким образом, цвет кнопки полностью управляется извне через `props`. [cite: 257]
* **Код:**

```tsx
export function StandartButton(props: ButtonProps) {
    // ...логика...
    return (
        <button className={`btn btn-${props.BGcolor}`}>
            {/* ...содержимое кнопки... */}
        </button>
    )
}
```

### Логика отображения: вынесение условия из JSX

* Ключевая особенность JSX: внутри него нельзя использовать стандартные управляющие конструкции JavaScript, такие как `if/else` или `for`. [cite: 274, 278, 279]
* Попытка написать `if` внутри `<button>{if (...) ...}</button>` приведет к ошибке.
* Правильный подход — вынести логику за пределы `return`. [cite: 282]
* Мы объявляем переменную, например `let content`.
* С помощью блока `if/else` мы присваиваем этой переменной нужное значение (либо строку, либо другой JSX-элемент). [cite: 283]
* И уже в самом `return` мы просто рендерим эту переменную: `{content}`. [cite: 285]

### ПРИМЕР №3.1.3: Код условного рендеринга

* Вся логика строится вокруг проверки свойства `props.btnType`. [cite: 261]
* Если `btnType` равен `"textButton"`, в переменную `content` записывается текст из `props.title`.
* В противном случае (если это `"iconButton"`), в `content` записывается JSX-элемент `<i>` для иконки. [cite: 262]
* Название класса для иконки также формируется динамически из `props.icon`. [cite: 323]
* **Код:** (ФАЙЛ: `src/components/StandartButton.tsx`)

```tsx
export function StandartButton(props: ButtonProps) {
    let content;
    if (props.btnType === "textButton") {
        content = props.title;
    } else {
        content = <i className={`bi bi-${props.icon}`}></i>;
    }

    return (
        <button className={`btn btn-${props.BGcolor}`}>
            {content}
        </button>
    );
}
```

******

## 4. Добавление интерактивности: Передача функции-обработчика через `props`

Наш компонент красив и гибок, но пока статичен. Чтобы он мог выполнять действия, нам нужно научить его обрабатывать события, например, клик мыши. Самый правильный и масштабируемый способ сделать это в React — передавать логику (функцию) извне через `props`.

### Цель этапа: научить кнопку выполнять действия

* Сделать компонент по-настоящему интерактивным, а не просто элементом отображения.
* Избежать "хардкодинга" (жесткого прописывания) логики внутри компонента, чтобы сохранить его универсальность. [cite: 626, 627]
* Понять, как родительский компонент может "говорить" дочернему, что делать при том или ином событии. [cite: 724]
* Освоить паттерн передачи функций-колбэков — один из фундаментальных в React. [cite: 381, 663]
* Увидеть, как TypeScript помогает типизировать даже передаваемые функции.

### Шаг 1: Расширение контракта для `onClick`

* Первым делом мы должны обновить наш `interface ButtonProps`, добавив в него новое свойство для обработчика клика.
* Мы назовем его `onClick`, по аналогии со стандартным HTML-атрибутом.
* Тип этого свойства будет `() => void`. [cite: 3, 4] Это специальный синтаксис TypeScript для описания функции. [cite: 686, 687, 688]
* `()` означает, что функция не принимает никаких аргументов. [cite: 689]
* `=> void` означает, что функция ничего не возвращает (`void`). [cite: 689]
* **ПРИМЕР №3.1.4** (ФАЙЛ: `src/components/StandartButton.tsx` - интерфейс)

```tsx
export interface ButtonProps {
    // ...старые свойства
    onClick: () => void;
}
```

******

### Шаг 2: Создание и экспорт внешних обработчиков

* Хорошей практикой является вынос логики, особенно переиспользуемой, в отдельные файлы. [cite: 650]
* Создадим новый файл, например `src/utils/handlers.ts`. Так как в нем не будет JSX-разметки, расширение будет `.ts`, а не `.tsx`. [cite: 693, 694, 695, 696]
* Внутри этого файла мы создадим и экспортируем несколько простых функций, которые будут выводить сообщения в `alert` или `console.log`. [cite: 700, 701, 702, 703]
* Ключевое слово `export` делает эти функции доступными для импорта в других файлах.
* **ПРИМЕР №3.1.4** (ФАЙЛ: `src/utils/handlers.ts`)

```tsx
export function printHello() {
    alert("Кнопка была нажата!");
}

export function consoleLogClick() {
    console.log("Обработчик сработал, событие в консоли.");
}
```

### Шаг 3: Связывание `props` с JSX-событием

* Теперь нам нужно "подключить" полученную через `props` функцию к реальному событию в браузере.
* В теге `<button>` мы используем стандартный для React атрибут `onClick`.
* В качестве его значения мы передаем функцию, которая пришла к нам в `props`: `onClick={props.onClick}`. [cite: 712, 713, 714]
* Таким образом, компонент `<StandardButton>` становится "проводником": он получает функцию извне и передает ее в обработчик `onClick` внутреннего тега `<button>`.
* Это позволяет каждой копии нашего компонента выполнять свою, уникальную логику. [cite: 382]
* **ПРИМЕР №3.1.4** (ФАЙЛ: `src/components/StandartButton.tsx` - реализация)

```tsx
export function StandartButton(props: ButtonProps) {
    // ... остальной код ...
    return (
        <button onClick={props.onClick} className={`btn btn-${props.BGcolor}`}>
            {content}
        </button>
    )
}
```

******

## 5. Создание "витрины": Компонент-контейнер для демонстрации

Мы создали универсальный "кубик" — компонент `<StandardButton>`. Теперь, чтобы увидеть всю его мощь, нам нужно собрать из этих "кубиков" что-то более сложное. Для этого мы создадим компонент-"витрину", единственная задача которого — показать нашу кнопку в разных вариациях. [cite: 390, 391]

### Цель этапа: применить принцип композиции на практике

* Понять, как из атомарных, простых компонентов собираются более сложные части интерфейса. [cite: 414]
* Научиться использовать один и тот же компонент многократно, но с разным набором `props`. [cite: 557]
* Использовать готовые компоненты (карточку Bootstrap) для быстрого построения UI. [cite: 397]
* Импортировать и использовать как наши собственные компоненты, так и внешние функции-обработчики.
* Получить наглядный и законченный результат, демонстрирующий всю проделанную работу.

### Шаг 1: Проектирование контейнера `SimpleButtonsGroup`

* Создаем новый компонент, например, `SimpleButtonsGroup.tsx`. [cite: 5]
* Он не будет принимать никаких `props`, его задача — просто отрендерить статичную композицию. [cite: 423]
* Для визуального оформления мы возьмем готовую разметку карточки из документации Bootstrap. [cite: 398, 399, 403, 404, 405]
* Важно помнить, что в JSX атрибут `class` нужно заменять на `className`. [cite: 425]
* Внутри карточки мы разместим заголовок, описание и специальный `div`, который будет служить flex-контейнером для наших кнопок. [cite: 442]

### Шаг 2: Импорт зависимостей

* Внутрь `SimpleButtonsGroup.tsx` нам нужно импортировать все, что мы собираемся использовать.
* Во-первых, наш собственный компонент `<StandardButton>`.
* Во-вторых, функции-обработчики `printHello` и `consoleLogClick` из файла `handlers.ts`.
* **Код импортов:**

    ```tsx
    import { StandartButton } from './StandartButton';
    import { printHello, consoleLogClick } from '../utils/handlers';
    ```

******

### Шаг 3: Рендеринг множества кнопок с разными `props`

* Это кульминация практикума. Внутри flex-контейнера мы несколько раз вызываем наш компонент `<StandardButton>`.
* Каждый вызов — это отдельная кнопка на экране.
* Каждой кнопке мы передаем свой, уникальный набор `props`: разный `BGcolor`, `icon`, `title`, `btnType` и `onClick`. [cite: 391]
* Это наглядно демонстрирует, как один и тот же код компонента генерирует совершенно разные по виду и поведению элементы интерфейса. [cite: 557]
* **ПРИМЕР №3.1.5** (ФАЙЛ: `src/components/SimpleButtonsGroup.tsx`)

```tsx
export function SimpleButtonsGroup() {
    return (
        <div className="card">
            <div className="card-body">
                {/* ...заголовки и текст... */}
                <div className="d-flex gap-2 justify-content-center">
                    <StandartButton BGcolor="dark" icon="eye-fill" title="Посмотреть" btnType="iconButton" onClick={consoleLogClick} />
                    <StandartButton BGcolor="warning" icon="basket-fill" title="В корзину" btnType="iconButton" onClick={printHello} />
                    <StandartButton BGcolor="danger" icon="heart-fill" title="В избранное" btnType="iconButton" onClick={printHello} />
                    {/* ... и так далее ... */}
                </div>
            </div>
        </div>
    )
}
```

### Шаг 4: Отображение финального результата

* Чтобы увидеть нашу "витрину" на странице, мы должны импортировать компонент `SimpleButtonsGroup` в точку входа приложения (`main.tsx` или `App.tsx`).
* После этого на экране должна появиться стилизованная карточка с набором разноцветных и функциональных кнопок. [cite: 436]
* Этот финальный результат доказывает успешное создание и применение нашего первого по-настоящему переиспользуемого React-компонента.

******

## 6. Стилизация композиции: Flexbox-выравнивание с помощью классов Bootstrap

Теперь, когда наша "витрина" функциональна, нужно придать ей эстетичный вид. Если просто разместить кнопки друг за другом, они "слипнутся" и будут выглядеть неаккуратно[cite: 415, 416]. Мы используем мощь Flexbox через готовые классы Bootstrap, чтобы быстро и без написания CSS-кода расположить элементы красиво.

### Цель этапа: освоить базовые утилиты Bootstrap для верстки

* Понять, как превратить обычный `<div>` во flex-контейнер.
* Научиться управлять отступами между элементами внутри flex-контейнера.
* Освоить классы для горизонтального выравнивания контента (по центру, по краям).
* Применить эти знания для финального оформления нашего компонента-витрины.
* Убедиться, что для решения большинства задач по верстке можно обойтись готовыми классами, не прибегая к написанию собственных стилей.

### Шаг 1: Создание контейнера для кнопок

* Первым делом, все наши компоненты `<StandardButton>` нужно обернуть в один родительский `<div>`[cite: 407, 408].
* Этот `div` и станет нашим управляющим контейнером.
* Именно к этому `div` мы будем применять классы, которые повлияют на расположение всех дочерних элементов (наших кнопок).
* Без такого контейнера управлять группой элементов как единым целым невозможно.

### Шаг 2: Превращение в Flex-контейнер (`d-flex`)

* Чтобы активировать магию Flexbox, мы добавляем нашему `div`-контейнеру класс `d-flex` (сокращение от `display: flex`).
* Этот класс — основа всей системы выравнивания в Bootstrap.
* После его добавления все дочерние элементы внутри `div` автоматически выстроятся в ряд.
* Мы также можем добавить класс `flex-wrap`, чтобы на маленьких экранах кнопки переносились на следующую строку, а не сжимались.

******

### Шаг 3: Управление отступами (`gap`)

* Чтобы кнопки не слипались, нужно задать между ними зазор.
* Для этого в Bootstrap есть утилита `gap`. Класс `gap-2` создаст небольшой, одинаковый отступ между всеми кнопками в контейнере[cite: 419].
* Bootstrap предлагает шкалу отступов от 1 до 5, что позволяет гибко настраивать расстояние[cite: 420, 421].
* Использование `gap` предпочтительнее, чем задавать `margin` каждой кнопке по отдельности, так как это проще и код выглядит чище.

### Шаг 4: Горизонтальное выравнивание (`justify-content`)

* По умолчанию flex-элементы прижимаются к левому краю. Чтобы расположить их по центру, мы используем утилиты `justify-content`.
* Класс `justify-content-center` выровняет все кнопки по центру их родительского контейнера[cite: 357, 427, 438].
* Существуют и другие варианты: `justify-content-start` (по левому краю), `justify-content-end` (по правому краю), `justify-content-between` (по краям с равным пространством между).
* **Итоговый код контейнера:** (ФАЙЛ: `src/components/SimpleButtonsGroup.tsx`)

```tsx
<div className="d-flex gap-2 flex-wrap justify-content-center">
    {/* ...здесь располагаются все наши компоненты <StandardButton>... */}
</div>
```

******

## 7. Подведение итогов: Ценность атомарного подхода

Мы успешно завершили практикум. Мы прошли путь от установки библиотек до создания сложной композиции из простого, но мощного компонента. Давайте закрепим ключевые идеи, которые лежат в основе этого подхода.

### Компонент как "кубик LEGO"

* Мы не создавали пять разных кнопок. Мы создали один компонент `<StandardButton>` — универсальный "атом" или "кубик", который можно настраивать как угодно[cite: 119, 121, 522].
* Этот компонент можно теперь импортировать и использовать в десятках разных мест нашего приложения, от карточки товара до формы настроек[cite: 344, 348, 718].
* Такой подход называется атомарным дизайном, и он лежит в основе всех современных UI-библиотек. Он упрощает поддержку и ускоряет разработку.
* Мы можем создать целую библиотеку таких "кубиков" и затем, как из конструктора, собирать из них интерфейсы любой сложности[cite: 121, 146].

### Props как "пульт управления"

* `props` — это не просто данные. Это полноценный "пульт управления" компонентом[cite: 343].
* Через `props` мы управляли всем:
  * **Внешним видом:** `BGcolor`, `btnType`.
  * **Содержимым:** `title`, `icon`.
  * **Поведением:** передавая функцию в `onClick`[cite: 346, 347].
* Такой декларативный подход делает код предсказуемым: глядя на вызов компонента, мы сразу понимаем, как он будет выглядеть и что будет делать.

******

### TypeScript как "гарантия надежности"

* Написание кода на TypeScript, особенно на начальном этапе, может показаться более многословным.
* Однако это инвестиция в надежность. TypeScript на 30% уменьшает количество потенциальных ошибок в проекте[cite: 315].
* Создав кастомный тип `BSColors`, мы защитили себя от опечаток и передачи некорректных цветов[cite: 226, 551, 555].
* Интерфейс `ButtonProps` сразу подсветил нам ошибки, когда мы забывали передать обязательное свойство или передавали его с неверным именем[cite: 310, 311].
* TypeScript — это наш "штурман", который не дает сбиться с курса и помогает писать более качественный и поддерживаемый код[cite: 315, 557].

### Декомпозиция и разделение ответственности

* Мы разделили наш код на логические части, каждая из которых отвечает за свою задачу.
* **`StandardButton.tsx`:** отвечает только за то, как выглядит и ведет себя *одна* кнопка.
* **`handlers.ts`:** отвечает только за бизнес-логику [что происходит при клике](cite: 615, 616).
* **`SimpleButtonsGroup.tsx`:** отвечает только за композицию — как несколько кнопок располагаются вместе.
* Такое разделение ответственности (Separation of Concerns) — ключевой принцип хорошей архитектуры. Он делает код проще для понимания, тестирования и будущих изменений.
