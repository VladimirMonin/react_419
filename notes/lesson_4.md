# Урок 4: Оживляем Компоненты — Состояние, Хуки и Реактивность в React ⚡️

## 1. Введение: Новая Проблема — Откуда Берётся Интерактивность?

На прошлом занятии мы научились строить красивые и переиспользуемые, но "немые" компоненты. Они получают данные через `props` и послушно их отображают. Но что, если данные должны меняться не снаружи, а в ответ на действия пользователя? Этот раздел ставит проблему, которую мы решим с помощью состояния.

### Мотивационный вопрос: что `props` не могут?

- `props` приходят в компонент извне, от родителя.
- Компонент не имеет права и не может изменять полученные `props`.
- Если мы хотим, чтобы компонент "запомнил" что-то, например, текст из поля ввода, `props` нам не помогут.
- Они предназначены для конфигурации, а не для хранения меняющихся во времени данных.
- Нам нужен механизм для создания "внутренней памяти" компонента.

### Примеры из жизни: лайки, поиск, фильтры

- Счетчик лайков, который увеличивается по клику.
- Текст в поисковой строке, который меняется при вводе.
- Галочка в чекбоксе, которая ставится и убирается.
- Всплывающее окно (модалка), которое открывается и закрывается.
- Все эти элементы интерфейса должны "помнить" свое текущее состояние.

******

### Ограничения однонаправленного потока данных

- Мы помним, что данные в React текут как водопад: сверху вниз.
- Этот принцип делает приложение предсказуемым.
- Однако он же и запрещает дочернему компоненту отправлять данные "наверх", изменяя `props`.
- Для интерактивности нам нужно что-то, что живет *внутри* компонента и не нарушает этот поток.
- Это "что-то" и есть состояние (state).

### Постановка цели урока: научить компоненты "помнить" и "реагировать"

- Наша главная цель — понять, что такое состояние.
- Мы изучим основной инструмент для работы с ним — хук `useState`.
- Мы научимся создавать компоненты, которые хранят данные внутри себя.
- Мы увидим, как React автоматически обновляет интерфейс в ответ на изменение этих данных.
- К концу урока наши приложения перестанут быть статичными и станут по-настоящему интерактивными.

******

## 2. Теория: Props vs State (Инструкция vs Внутренняя Память)

Чтобы не путаться, давайте раз и навсегда разграничим эти два фундаментальных понятия. Лучший способ сделать это — использовать простую и понятную аналогию из реального мира. Представим, что наш компонент — это строитель, который возводит стену.

### Аналогия: `props` как чертеж дома

- `props` — это неизменный чертеж и спецификация, которые строителю выдал архитектор (родительский компонент).
- В чертеже указано: "стена должна быть высотой 3 метра, синего цвета, из кирпича".
- Строитель (компонент) обязан следовать этим инструкциям.
- Он не может по своему желанию изменить цвет стены на красный или высоту на 5 метров.
- `props` — это то, *что* компонент получает.

### Аналогия: `state` как инструменты и заметки строителя

- `state` — это личные инструменты, заметки и состояние самого строителя.
- Например, сколько кирпичей он уже уложил, устал он или нет, какой инструмент у него сейчас в руке.
- Эти данные принадлежат только строителю (компоненту) и он сам ими управляет.
- Архитектору (родителю) неважно, сколько раз строитель сделал перерыв, ему важен результат.
- `state` — это то, *чем* компонент владеет и что он отслеживает.

******

### Ключевое различие: кто контролирует данные

- Данные из `props` контролируются родительским компонентом.
- Данные из `state` контролируются самим компонентом.
- `props` передаются в компонент.
- `state` создается и управляется внутри компонента.
- Это главное концептуальное различие, которое нужно запомнить.

### `props` — "read-only" (только для чтения)

- Компонент может только читать `props` и использовать их для рендеринга.
- Попытка изменить `props` (`props.name = 'новое значение'`) вызовет ошибку.
- Это гарантирует предсказуемость: если компонент выглядит не так, как ожидалось, мы знаем, что проблема в родительском элементе, который передал не те `props`.
- Неизменяемость (immutability) `props` — это фундаментальный принцип React.

******

## 3. Главная "Магия" React: Концепция Реактивности

Мы подошли к самому важному. Почему изменение какой-то переменной вдруг заставляет перерисовываться часть страницы? Это и есть реактивность — ключевая особенность, которая делает React таким мощным инструментом.

### Проблема "ванильного" JS: ручное обновление DOM

- В обычном JavaScript, чтобы обновить текст на странице, нам нужно было выполнить несколько шагов.
- Сначала найти нужный HTML-элемент в DOM-дереве.
- Затем вручную изменить его свойство, например, `innerHTML` или `textContent`.
- Этот подход называется императивным: мы даем браузеру пошаговые инструкции, *как* изменить UI.
- Это приводит к сложному, запутанному коду, особенно в больших приложениях.

### Пример императивного подхода

- `const counterValue = 5;`
- `const counterElement = document.getElementById('counter');`
- `if (counterElement) { counterElement.innerHTML = counterValue; }`
- Чтобы обновить счетчик, нам нужно снова найти элемент и снова изменить его.
- Мы полностью отвечаем за синхронизацию данных и их отображения.

******

### Решение React: декларативный подход

- React избавляет нас от необходимости вручную манипулировать DOM.
- Мы просто объявляем, как интерфейс должен выглядеть для определенного состояния.
- Мы говорим React: "Если `isLoggedIn` равно `true`, покажи компонент `<UserProfile/>`, иначе покажи `<LoginForm/>`".
- Мы описываем *что* мы хотим видеть, а не *как* этого достичь.
- React берет на себя всю "грязную" работу по обновлению DOM.

### Цепочка событий: Изменение state -> React "видит" -> React перерисовывает UI

- Когда мы изменяем состояние компонента (используя специальную функцию, о которой скоро узнаем)...
- React немедленно обнаруживает это изменение.
- Он создает новую, виртуальную версию DOM-дерева.
- Затем он сравнивает эту новую версию со старой, находит минимальные различия.
- И наконец, точечно обновляет только измененную часть реального DOM в браузере.
- Этот процесс называется "reconciliation" (сверка) и он очень эффективен.

******

## 4. Введение в Хуки: Новый Способ Работы с Компонентами

Раньше для использования состояния и других возможностей React нужно было писать классовые компоненты. Это было сложнее и многословнее. Но с появлением хуков функциональные компоненты стали такими же мощными, и сегодня это стандарт разработки на React.

### Исторический контекст: классовые компоненты

- Раньше компоненты, которым нужно было состояние, писались как классы JavaScript.
- Они наследовали `React.Component` и использовали `this.state` и `this.setState()`.
- Этот подход требовал разбираться с контекстом `this`, методами жизненного цикла и более сложным синтаксисом.
- Функциональные компоненты были "глупыми" и умели только рендерить `props`.
- Хуки полностью изменили эту парадигму.

### Что такое хуки: функции, дающие доступ к возможностям React

- Хуки (Hooks) — это специальные функции, которые позволяют "подцепиться" к состоянию и другим возможностям React из функциональных компонентов.
- Они дают нам доступ к тому, что раньше было доступно только в классах.
- Хуки сделали код более простым, лаконичным и читаемым.
- Они позволяют легко переиспользовать логику с состоянием между компонентами.
- `useState` — это самый первый и самый важный хук, с которым мы познакомимся.

******

### Два главных правила хуков

- **Правило №1:** Вызывайте хуки только на верхнем уровне вашей React-функции. Нельзя вызывать их внутри циклов, условий или вложенных функций.
- **Правило №2:** Вызывайте хуки только из функциональных компонентов React или из других кастомных хуков. Не вызывайте их из обычных JavaScript-функций.
- Эти правила гарантируют, что React сможет корректно отслеживать вызовы хуков между рендерами.
- Современные линтеры (программы для проверки кода) обычно автоматически следят за соблюдением этих правил.

### Конвенция именования: всегда начинаются с `use...`

- Все встроенные хуки в React начинаются с префикса `use`, например: `useState`, `useEffect`, `useContext`.
- Когда мы создаем свои собственные хуки (а мы научимся это делать позже), мы также обязаны следовать этому соглашению.
- Это не просто традиция, а требование, которое позволяет инструментам анализа кода автоматически определять, что функция является хуком и применять к ней особые правила.

******

## 5. Основной Инструмент: Детальный Разбор Хука `useState`

Перейдем от теории к коду. `useState` — это наш основной инструмент для добавления "памяти" в компоненты. Это функция, которую мы вызываем, чтобы сообщить React, что этот компонент должен хранить какое-то состояние.

### Назначение: добавить состояние в функциональный компонент

- Основная и единственная задача `useState` — объявить переменную состояния.
- Вызывая `useState`, мы как бы говорим React: "Эй, выдели, пожалуйста, ячейку памяти для этого компонента. Я буду хранить там данные, и когда они изменятся, не забудь перерисовать компонент".
- Мы можем вызывать `useState` несколько раз в одном компоненте, чтобы создать несколько независимых переменных состояния.
- Например, одна для счетчика, другая для текста в поле ввода, третья для флага "загружается ли...".

### Импорт из библиотеки React

- `useState` — это именованный экспорт из библиотеки `react`.
- Поэтому перед использованием его всегда нужно импортировать в начале файла.
- Синтаксис импорта выглядит так: `import { useState } from 'react';`.
- Если вы используете современный фреймворк вроде Next.js или Create React App, иногда `React` импортируется автоматически, но лучше всегда указывать импорт `useState` явно для ясности.

******

### Что `useState` принимает в качестве аргумента

- Хук `useState` принимает один необязательный аргумент.
- Этот аргумент — начальное (initial) значение для нашей переменной состояния.
- Это может быть что угодно: число, строка, булево значение, массив, объект.
- `useState(0)` — состояние начнется с числа 0.
- `useState('')` — состояние начнется с пустой строки.
- `useState(false)` — состояние начнется со значения `false`.

### `initialValue`: значение при первом рендере

- Важно понимать, что этот аргумент используется React только *один раз* — во время самого первого рендера компонента.
- При всех последующих рендерах React будет игнорировать это начальное значение.
- Вместо этого он будет возвращать актуальное, текущее значение состояния, которое хранится в его "памяти".
- Это гарантирует, что состояние сохраняется между перерисовками компонента.

******

## 6. Синтаксис `useState`: Массив из Двух Элементов [`value`, `setValue`]

Самая необычная на первый взгляд часть `useState` — это то, как мы получаем из него данные. Он возвращает не просто значение, а массив из двух элементов, который мы почти всегда обрабатываем с помощью синтаксиса деструктуризации.

### Возвращаемое значение: `useState` возвращает массив

- Вызов `useState(initialValue)` возвращает массив, в котором всегда ровно два элемента.
- Первый элемент — это текущее значение состояния.
- Второй элемент — это специальная функция для обновления этого значения.
- Например: `const stateArray = useState(0); // stateArray будет равен [0, function]`
- Работать с таким массивом по индексам (`stateArray[0]`, `stateArray[1]`) неудобно, поэтому так никто не делает.

### Использование деструктуризации массива

- Мы используем синтаксис деструктуризации массива из ES6, чтобы сразу присвоить этим двум элементам понятные имена.
- `const [count, setCount] = useState(0);`
- Эта строчка делает три вещи одновременно:
- 1. Создает новую переменную состояния `count` и инициализирует ее значением `0`.
- 2. Создает переменную `setCount`, в которой лежит функция для обновления `count`.
- 3. Связывает их вместе в "памяти" React.

******

### Первый элемент (`value`): переменная с текущим значением

- Первая переменная (в нашем примере `count`) — это "читаемая" часть состояния.
- Мы используем ее в нашем JSX, чтобы отобразить текущее значение.
- `<h1>Текущий счет: {count}</h1>`
- Мы никогда не должны пытаться изменить ее напрямую, например, `count = count + 1;`. Это не сработает и нарушит принципы React.

### Второй элемент (`setValue`): функция для обновления

- Вторая переменная (`setCount`) — это "записывающая" часть состояния.
- Это единственно правильный способ изменить значение состояния.
- Мы вызываем эту функцию, когда хотим обновить состояние, например, в обработчике клика.
- `<button onClick={() => setCount(count + 1)}>Увеличить</button>`
- Именно вызов этой функции сообщает React, что состояние изменилось и пора запускать процесс перерисовки (ре-рендера).

******

## 7. Практикум №1: Создаем Компонент-Счетчик (`number` в состоянии)

Теория — это хорошо, но React лучше всего изучать на практике. Давайте создадим наш первый интерактивный компонент. Это классическая задача "счетчик", которая идеально демонстрирует базовый цикл обновления состояния.

### Постановка задачи: компонент с числом и двумя кнопками

- Нам нужно отобразить на экране число (начальное значение 0).
- Под числом должны быть две кнопки: "+" (Увеличить) и "-" (Уменьшить).
- При нажатии на "+" число должно увеличиваться на единицу.
- При нажатии на "-" число должно уменьшаться на единицу.
- Компонент должен полностью управлять своим состоянием без участия извне.

### Шаг 1: Создание компонента и импорт `useState`

- Создаем новый файл, например `Counter.tsx`.
- Пишем базовую структуру функционального компонента: `export function Counter() { return (...); }`.
- Первым делом импортируем хук `useState` из React: `import { useState } from 'react';`.
- Внутри JSX сразу набрасываем верстку: `div`, `h1` для числа и два элемента `button`.

### Шаг 2: Инициализация состояния

- Внутри компонента, на самом верхнем уровне, вызываем `useState`.
- В качестве начального значения передаем `0`, так как счетчик должен начинаться с нуля.
- Используем деструктуризацию, чтобы получить переменную и функцию: `const [count, setCount] = useState(0);`.
- `count` будет хранить текущее значение счетчика.
- `setCount` — функция, которую мы будем вызывать для изменения этого значения.

******

### Шаг 3: Отображение состояния в JSX

- Теперь нам нужно, чтобы наш `<h1>` всегда показывал актуальное значение счетчика.
- Для этого мы используем фигурные скобки `{}` для вставки JavaScript-выражений в JSX.
- Заменяем статичное число на нашу переменную состояния: `<h1>Счетчик: {count}</h1>`.
- Теперь React знает, что содержимое этого заголовка зависит от состояния `count`.

### Шаг 4: Создание и привязка обработчиков

- Создаем две функции внутри компонента: `handleIncrement` и `handleDecrement`.
- В `handleIncrement` мы вызываем `setCount`, передавая ей новое значение: `setCount(count + 1);`.
- В `handleDecrement` делаем то же самое, но с вычитанием: `setCount(count - 1);`.
- Привязываем эти функции к событию `onClick` наших кнопок: `<button onClick={handleIncrement}>+</button>`.
- Теперь при каждом клике будет вызываться нужная функция, которая, в свою очередь, обновит состояние.

******

## 8. Практикум №2: Создаем Переключатель (Toggler) (`boolean` в состоянии)

Числа — это просто. Давайте поработаем с другим важным типом данных в состоянии — булевым (`true`/`false`). Это основа для множества элементов интерфейса: выпадающие меню, модальные окна, чекбоксы и любые переключатели "вкл/выкл".

### Постановка задачи: показать/скрыть элемент

- Нам нужна кнопка с текстом "Показать".
- Рядом с кнопкой есть некий блок с текстом, который изначально скрыт.
- При клике на кнопку "Показать" текст должен появиться, а надпись на кнопке измениться на "Скрыть".
- При повторном клике текст должен снова исчезнуть, а надпись на кнопке вернуться к "Показать".

### Инициализация булева состояния

- Создаем новый компонент `Toggler.tsx`.
- Инициализируем состояние, которое будет отвечать за видимость элемента. Начальное значение — `false` (скрыто).
- `const [isVisible, setIsVisible] = useState(false);`
- `isVisible` — флаг, который мы будем проверять.
- `setIsVisible` — функция для переключения этого флага.

### Условный рендеринг с оператором `&&`

- Мы можем использовать короткую запись с логическим "И" (`&&`) для рендеринга элемента по условию.
- Выражение `условие && <Разметка />` вернет `<Разметка />` только если `условие` истинно (`true`).
- В нашем JSX пишем: `{isVisible && <p>Этот текст можно скрыть!</p>}`.
- Теперь этот абзац будет отрендерен только тогда, когда `isVisible` будет `true`.

******

### Логика переключения: `setIsVisible(!isVisible)`

- Создаем функцию-обработчик `handleToggle`.
- Внутри нее нам нужно инвертировать текущее значение `isVisible`.
- Для этого используем логический оператор "НЕ" (`!`).
- `setIsVisible(!isVisible);` — эта команда говорит React: "установи новое значение состояния в противоположность тому, что было до этого".
- Если было `false`, станет `true`, и наоборот.

### Динамический текст на кнопке

- Чтобы текст на кнопке менялся, мы можем использовать тернарный оператор прямо в JSX.
- `<button onClick={handleToggle}>{isVisible ? 'Скрыть' : 'Показать'}</button>`
- Эта запись читается так: "Если `isVisible` равно `true`, показать текст 'Скрыть', в противном случае — 'Показать'".
- Теперь наш компонент полностью интерактивен и управляет как видимостью элемента, так и собственным текстом.

******

## 9. Важное Правило: Почему Нельзя Мутировать Состояние Напрямую

Это одна из самых частых ошибок новичков. Кажется логичным просто изменить переменную состояния, но это нарушает основной принцип работы React и не приведет к ожидаемому результату.

### Анти-паттерн: демонстрация неработающего кода

- Представим наш счетчик: `const [count, setCount] = useState(0);`.
- Что, если в обработчике написать так: `const handleClick = () => { count++; console.log(count); }`.
- В консоли мы увидим, что `count` действительно увеличивается.
- Однако на экране число останется прежним. Пользователь не увидит никаких изменений.
- Это происходит потому, что мы не сообщили React о необходимости обновления.

### Объяснение: React не "видит" прямое изменение

- React запускает ре-рендер только тогда, когда вызывается функция-сеттер (`set...`).
- Прямое изменение переменной (мутация) не вызывает эту функцию.
- React просто не знает, что данные изменились, и у него нет причин перерисовывать компонент.
- Он не отслеживает каждую переменную "на лету"; он реагирует только на вызов специальных функций-сеттеров.

******

### Правильный подход для объектов и массивов

- С примитивами (числа, строки) мутация и так не сработает. Но с объектами и массивами все сложнее.
- **Неправильно:** `const [user, setUser] = useState({ name: 'Анна' }); ... user.name = 'Ольга'; setUser(user);`
- React сравнит ссылки на старый и новый объект `user`, увидит, что это один и тот же объект, и решит, что ничего не изменилось.
- **Правильно:** Всегда создавать *новый* объект или массив на основе старого.
- `setUser({ ...user, name: 'Ольга' });` — мы создаем новый объект с помощью spread-оператора, копируя старые свойства и перезаписывая нужное.
- `setItems([...items, newItem]);` — создаем новый массив, копируя старые элементы и добавляя новый.

### Итог: Иммутабельность — ваш лучший друг

- Принцип неизменяемости (иммутабельности) — ключевой в React.
- Вместо того чтобы изменять существующие данные, мы всегда создаем их новые версии.
- Это делает поток данных предсказуемым и помогает избежать множества трудноотлавливаемых ошибок.
- Всегда используйте функцию-сеттер и создавайте новые копии для объектов и массивов.

******

## 10. Паттерн "Управляемый Компонент": React как Единственный Источник Правды

Работа с формами (поля ввода, чекбоксы, списки) — неотъемлемая часть веб-приложений. В React существует особый, очень мощный паттерн для работы с ними, который называется "управляемый компонент".

### Проблема HTML-форм: состояние в DOM

- По умолчанию, обычные HTML-элементы форм, такие как `<input>`, сами хранят и управляют своим состоянием.
- Когда вы печатаете в поле ввода, именно DOM-узел этого поля "помнит", какой в нем сейчас текст.
- Это значит, что "источник правды" находится в DOM, а не в нашем JavaScript-коде.
- В сложных приложениях это может привести к рассинхронизации данных.

### Концепция "Единственного источника правды"

- В React принято, чтобы у любых данных был только один "хозяин" или "источник правды".
- Для данных, которые могут меняться, этим источником всегда должно быть состояние (`state`) компонента React.
- Это значит, что мы должны "забрать" у DOM-элемента формы право хранить свое состояние и передать его React.

******

### "Управляемый компонент" — что это?

- Управляемый компонент — это элемент формы (например, `<input>`), значение (`value`) которого полностью контролируется состоянием React.
- Любое изменение этого значения происходит только через обновление состояния.
- Поле ввода больше не решает, что в нем отображается. Оно лишь отображает то, что ему сказало состояние React.
- Таким образом, React-компонент становится единственным "хозяином" данных формы.

### Преимущества такого подхода

- **Предсказуемость:** Значение поля ввода всегда синхронизировано с состоянием. Мы в любой момент знаем, что введено в поле, просто посмотрев на `state`.
- **Простая валидация:** Мы можем легко проверять и изменять вводимые данные "на лету".
- **Гибкость:** Мы можем легко сбрасывать, форматировать или передавать значение из поля ввода другим компонентам.
- **Централизованное управление:** Вся логика работы формы сосредоточена в одном месте — в компоненте React.

******

## 11. Практикум №3: Создаем Управляемое Поле Ввода (`string` в состоянии)

Давайте применим теорию на практике и создадим наш первый управляемый компонент. Это фундаментальный паттерн, который вы будете использовать постоянно.

### Постановка задачи

- Создать компонент, который содержит текстовое поле `<input type="text">`.
- Под полем ввода должен в реальном времени отображаться текст, который в него вводится.
- Это покажет, что мы действительно управляем значением через состояние.

### Шаг 1: Инициализация строкового состояния

- Создаем компонент `ControlledInput.tsx`.
- Нам нужно состояние для хранения текста из поля ввода. Тип данных — строка, начальное значение — пустая строка.
- `const [inputValue, setInputValue] = useState('');`

### Шаг 2: Создание и связывание JSX

- В разметке создаем `<input>` и, например, `<p>` для вывода значения.
- Теперь самое главное — нужно установить двустороннюю связь между `input` и состоянием.
- **Связь №1 (State -> Input):** Мы привязываем атрибут `value` инпута к нашему состоянию: `<input value={inputValue} />`. Теперь `input` всегда будет показывать то, что лежит в `inputValue`.
- **Связь №2 (Input -> State):** Мы должны обновлять состояние, когда пользователь что-то печатает. Для этого используем атрибут `onChange`.

******

### Шаг 3: Реализация обработчика `onChange`

- Создаем функцию `handleChange`. Она автоматически получит объект события `event`.
- `const handleChange = (event) => { ... }`
- Значение, введенное пользователем, находится в `event.target.value`.
- Внутри обработчика мы вызываем наш сеттер и передаем ему это новое значение: `setInputValue(event.target.value);`.
- Теперь привязываем этот обработчик к инпуту: `<input value={inputValue} onChange={handleChange} />`.

### Шаг 4: Отображение результата

- Чтобы убедиться, что состояние действительно обновляется, выведем его значение под полем ввода.
- `<p>Текущее значение: {inputValue}</p>`
- Запускаем код и видим: при каждом нажатии клавиши в поле ввода текст под ним мгновенно обновляется. Мы полностью контролируем процесс.

******

## 12. Визуализация Потока Данных в Управляемом Компоненте

Поначалу цикл обновления в управляемом компоненте может показаться немного запутанным. Давайте разложим его по полочкам, чтобы увидеть, что происходит под капотом при каждом нажатии клавиши.

### Шаг 1: Пользователь нажимает клавишу

- Все начинается с действия пользователя. Он нажимает, например, клавишу "А" в пустом поле ввода.
- Браузер регистрирует это событие.

### Шаг 2: Срабатывает событие `onChange`

- Так как содержимое `<input>` пытается измениться, браузер инициирует событие `onChange`.
- React "слушает" это событие, так как мы передали ему обработчик в атрибуте `onChange`.

### Шаг 3: Вызывается обработчик `handleChange`

- React вызывает нашу функцию `handleChange`, которую мы написали.
- В качестве аргумента в нее автоматически передается объект события `event`. В `event.target.value` теперь лежит строка "А".

******

### Шаг 4: Вызывается `setInputValue('А')`

- Внутри `handleChange` мы вызываем `setInputValue(event.target.value)`.
- Это ключевой момент: мы говорим React: "Пожалуйста, запланируй обновление. Новое значение для состояния `inputValue` теперь 'А'".

### Шаг 5: React планирует ре-рендер

- Получив команду от `setInputValue`, React понимает, что состояние компонента изменилось.
- Он ставит этот компонент в очередь на перерисовку (ре-рендер).

### Шаг 6: Компонент рендерится с новым состоянием

- React заново выполняет код нашего компонента.
- Теперь, когда он доходит до `const [inputValue, ...] = useState('')`, `useState` возвращает уже новое, актуальное значение — "А".
- Затем React доходит до JSX и видит `<input value={inputValue} ... />`.
- Он передает в `value` инпута новое значение "А". Поле ввода обновляется.

### Итог: Замкнутый круг

- Мы видим замкнутый цикл: **Действие пользователя -> `onChange` -> `setState` -> Ре-рендер -> Новое `value` в `input`**.
- Хотя кажется, что мы печатаем напрямую в поле, на самом деле мы запускаем этот очень быстрый цикл обновления React.

******

## 13. Финальный Воркшоп: Ставим Задачу — Фильтрация Списка Товаров

Время объединить все, что мы сегодня изучили: компоненты, `props`, `state` и управляемый ввод. Мы создадим одну из самых распространенных функций в веб-приложениях — "живой" поиск или фильтрацию списка. Это идеальная задача, чтобы увидеть всю мощь реактивности в действии.

### Цель: собрать все знания в одной полезной задаче

- Мы перестанем работать с изолированными примерами (счетчики, переключатели).
- Наша цель — применить полученные навыки для создания реальной, полезной функциональности.
- Этот воркшоп покажет, как `props` и `state` работают вместе для создания сложных интерактивных интерфейсов.
- Мы увидим, как один `state` (текст в поиске) может управлять отображением целой коллекции компонентов.

### Задача: создать "живой" поиск по карточкам

- У нас есть массив объектов, описывающих товары.
- У нас есть компонент `<ProductCard>`, который умеет отображать один товар (мы создавали его на прошлом уроке).
- Нам нужно отобразить список всех этих товаров на странице.
- Над списком мы добавим текстовое поле `<input>`.
- При вводе текста в это поле, список товаров должен мгновенно, без перезагрузки страницы, отфильтровываться, показывая только те карточки, название которых содержит введенный текст.

******

### Исходные данные и компоненты

- Мы будем использовать компонент `<ProductCard>` из прошлого домашнего задания.
- Он принимает данные о товаре через `props`.
- Массив с данными о товарах мы определим как константу прямо в коде нашего нового компонента-контейнера.
- Это позволит нам сосредоточиться именно на логике состояния и фильтрации.

### План действий

- 1. Создать компонент-контейнер, который будет отображать все товары и поле ввода.
- 2. Сделать поле ввода управляемым, заведя для него отдельную переменную состояния.
- 3. Написать логику, которая будет фильтровать исходный массив товаров на основе значения из состояния.
- 4. Рендерить не весь массив, а только отфильтрованный результат.

******

## 14. Шаг 1: Подготовка Данных и UI (Компонент `ProductList`)

Прежде чем добавлять интерактивность, нам нужно создать статическую основу: страницу, которая просто отображает все товары из нашего массива данных.

### Создание родительского компонента

- Создаем новый файл, например, `ProductPage.tsx`.
- Внутри него создаем и экспортируем функциональный компонент `ProductPage`.
- Этот компонент будет "владельцем" состояния и логики фильтрации.

### Определение массива данных

- Прямо внутри файла `ProductPage.tsx` (но снаружи самого компонента) определяем массив с данными.
- `const allProducts = [ { id: 1, name: 'Ноутбук' }, { id: 2, name: 'Смартфон' }, ... ];`
- Вынесение его за пределы компонента — это небольшая оптимизация: так массив не будет создаваться заново при каждом ре-рендере.

******

### Базовая разметка UI

- Внутри `return` компонента `ProductPage` создаем основную структуру.
- Корневой `<div>`.
- Заголовок `<h1>Каталог товаров</h1>`.
- Элемент `<input type="text" placeholder="Найти товар..." />`.
- `<div>`, который будет служить контейнером для наших карточек.

### Рендеринг полного списка через `.map()`

- Внутри контейнера для карточек мы используем метод `.map()` для итерации по нашему массиву `allProducts`.
- На каждой итерации мы возвращаем компонент `<ProductCard>`, передавая в него данные о текущем товаре.
- `{allProducts.map(product => <ProductCard key={product.id} product={product} />)}`
- **Важно:** не забываем про `key`! Он критически важен для React при рендеринге списков.
- На этом этапе у нас должна отобразиться страница со всеми товарами и неработающим полем ввода.

******

## 15. Шаг 2: Добавление Состояния для Поискового Запроса

Теперь оживим наше поле ввода. Его значение — это классический пример данных, которые должны храниться в состоянии, так как они меняются со временем по действию пользователя.

### Анализ: что здесь должно быть состоянием?

- Текст, который пользователь вводит в поисковую строку, — это и есть наше состояние.
- Оно начинается с пустой строки и меняется с каждым нажатием клавиши.
- Это состояние будет "управлять" фильтрацией.

### Инициализация состояния

- Импортируем `useState` в наш компонент `ProductPage`.
- Создаем новую переменную состояния: `const [searchQuery, setSearchQuery] = useState('');`.
- Мы выбрали говорящие имена: `searchQuery` (поисковый запрос) и `setSearchQuery`.
- Начальное значение — пустая строка, так как при первой загрузке фильтра быть не должно.

### Превращение `<input>` в управляемый компонент

- Теперь мы должны связать наш `<input>` с созданным состоянием.
- **Шаг 1:** Привязываем `value` инпута к состоянию: `value={searchQuery}`.
- **Шаг 2:** Создаем обработчик `onChange`: `const handleSearchChange = (event) => { setSearchQuery(event.target.value); }`.
- **Шаг 3:** Передаем этот обработчик в `input`: `onChange={handleSearchChange}`.
- Готово! Теперь наш `input` — управляемый.

### Проверка работы состояния

- Чтобы убедиться, что все работает, можно временно добавить под полем ввода строку:
- `<p>Вы ищете: {searchQuery}</p>`
- Теперь, когда мы будем печатать в `input`, мы должны видеть, как этот текст синхронно появляется в абзаце ниже. Это доказывает, что состояние обновляется корректно.

******

## 16. Шаг 3: Логика Фильтрации перед Рендерингом

У нас есть полный список товаров и есть актуальный поисковый запрос в состоянии. Осталось их соединить. Ключевая идея — фильтрация происходит прямо во время рендеринга, на основе текущего состояния.

### Где должна быть логика фильтрации?

- Логика фильтрации — это "вычисляемое" значение. Она напрямую зависит от `allProducts` (не меняется) и `searchQuery` (состояние).
- Ее не нужно помещать в `useEffect` или сложные обработчики.
- Самое простое и правильное место — прямо в теле компонента, перед оператором `return`.

### Создание нового, отфильтрованного массива

- Внутри `ProductPage`, после объявления состояния, но до `return`, пишем логику.
- `const filteredProducts = allProducts.filter(product => ...);`
- Мы создаем *новую* константу, которая будет содержать только те товары, которые прошли проверку.

******

### Реализация логики фильтрации

- Мы хотим, чтобы поиск был нечувствителен к регистру (чтобы "Ноутбук" находился по запросу "ноут").
- Для этого приводим и название товара, и поисковый запрос к нижнему регистру с помощью `.toLowerCase()`.
- Используем метод `.includes()`, чтобы проверить, содержит ли название товара поисковую подстроку.
- `product.name.toLowerCase().includes(searchQuery.toLowerCase())`

### Использование отфильтрованного массива в `.map()`

- Теперь финальный штрих. В JSX, где мы рендерим список, мы заменяем исходный массив `allProducts` на наш новый, вычисленный `filteredProducts`.
- **Было:** `{allProducts.map(product => ...)}`
- **Стало:** `{filteredProducts.map(product => ...)}`
- Вот и все! Теперь при каждом изменении `searchQuery` компонент будет перерисовываться, логика фильтрации будет выполняться заново с новым значением, и `.map()` будет рендерить уже отфильтрованный список. Магия реактивности в действии!

******

## 17. Обзор Полученных Навыков: Что Теперь в Нашем Арсенале?

Давайте сделаем шаг назад и оценим, какими мощными инструментами мы овладели за этот урок. Мы прошли путь от статичных "болванок" до компонентов, которые могут помнить, реагировать и управлять своим поведением.

### Разница `props` и `state`

- Мы четко разграничили `props` (внешняя конфигурация, "чертеж") и `state` (внутренняя память, "заметки строителя").
- Это понимание — фундамент для проектирования любых React-компонентов.

### Хук `useState`

- Мы освоили `useState` — основной хук для добавления состояния в функциональные компоненты.
- Мы понимаем его синтаксис `[value, setValue]` и знаем, что вызов `setValue` — единственный способ запустить ре-рендер.

******

### Работа с разными типами данных

- Мы попрактиковались в хранении и обновлении разных типов данных в состоянии:
- `number` (счетчик)
- `boolean` (переключатель)
- `string` (управляемое поле ввода)

### Иммутабельность и паттерн "управляемый компонент"

- Мы усвоили золотое правило: никогда не мутировать состояние напрямую, а всегда создавать его новые копии.
- Мы научились создавать управляемые компоненты — стандартный и надежный способ работы с формами в React.

### Объединение концепций в единое целое

- Самое главное — мы увидели, как все эти концепции работают вместе для создания сложной интерактивности.
- На примере фильтрации мы проследили полный цикл: **Действие пользователя -> Обновление `state` -> Ре-рендер -> Пересчет производных данных -> Обновление UI**.

******

## 18. Домашнее Задание и Анонс Следующей Темы (`useEffect`)

Практика — ключ к закреплению материала. Следующее домашнее задание поможет вам отточить навыки работы с состоянием и подготовиться к новой, не менее важной теме.

### Задание 1 (Базовое): Расширяем фильтрацию

- Возьмите готовый воркшоп с фильтрацией товаров.
- Добавьте под полем ввода чекбокс `<input type="checkbox" />` с подписью "Только в наличии".
- Добавьте в исходные данные для каждого товара свойство `inStock: true/false`.
- Создайте *вторую* переменную состояния для чекбокса (`const [inStockOnly, setInStockOnly] = useState(false);`).
- Измените логику фильтрации так, чтобы она учитывала и текстовый поиск, и состояние чекбокса.

### Задание 2 (Продвинутое): Форма регистрации

- Создайте компонент `RegistrationForm`.
- В нем должно быть три поля: имя, email, пароль.
- Сделайте все три поля управляемыми, создав для каждого из них свое состояние.
- Добавьте кнопку "Зарегистрироваться".
- При нажатии на кнопку выводите в `console.log` объект со значениями всех трех состояний: `{ name: '...', email: '...', password: '...' }`.

### Анонс следующего урока: Побочные эффекты и `useEffect`

- "Наши компоненты научились отлично реагировать на действия пользователя. Но что, если нам нужно выполнить какое-то действие не в ответ на клик, а в ответ на *событие из жизни самого компонента*? Например, загрузить данные с сервера, как только компонент впервые появился на экране? Или подписаться на какие-то события и отписаться, когда компонент исчезает? Для всего этого существует второй по важности хук — `useEffect`, который управляет **побочными эффектами**. Этим мы и займемся в следующий раз."
